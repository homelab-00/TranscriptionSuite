#!/usr/bin/env bash
# hooks/pre-commit  (tracked in git — active via `git config core.hooksPath hooks`)
#
# TranscriptionSuite pre-commit hook
# -----------------------------------
# Runs code-quality and contract checks before every commit.
#
# ADDING NEW CHECKS
# -----------------
# 1. Write a function named check_<something>() that returns 0 on success,
#    non-zero on failure. Use the pass/fail/info/header helpers for output.
# 2. Append the function name to the CHECKS array at the bottom.
#
# The runner calls every function in order and tallies failures; a commit is
# only aborted if at least one check fails.

set -euo pipefail

REPO_ROOT="$(git rev-parse --show-toplevel)"

# ── colours ────────────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
RESET='\033[0m'

pass()   { printf "%b\n" "${GREEN}  ✔ $*${RESET}"; }
fail()   { printf "%b\n" "${RED}  ✖ $*${RESET}"; }
info()   { printf "%b\n" "${CYAN}  → $*${RESET}"; }
header() { printf "%b\n" "\n${BOLD}${YELLOW}[$*]${RESET}"; }

# ── helpers ────────────────────────────────────────────────────────────────

# Returns true (0) if any tracked file changed in the working tree relative
# to the index (i.e. an in-place formatter modified a staged file on disk).
_staged_files_modified() {
    # git diff --name-only: unstaged differences between index and work-tree
    git diff --name-only -- "${REPO_ROOT}" | grep -qE "${1:-.}" 2>/dev/null
}

# ── check functions ────────────────────────────────────────────────────────

check_python_format() {
    header "Python · ruff format"

    local ruff="${REPO_ROOT}/build/.venv/bin/ruff"
    if [[ ! -x "$ruff" ]]; then
        fail "ruff not found at ${ruff}"
        info  "Fix: cd build && uv sync"
        return 1
    fi

    info "Formatting Python files (ruff format) …"
    "${ruff}" format "${REPO_ROOT}" --quiet

    if _staged_files_modified '\.py$'; then
        fail "Python files were reformatted by ruff — re-stage the changes and commit again"
        return 1
    fi

    pass "Python formatting OK"
}

check_dashboard_format() {
    header "Dashboard · Prettier"

    if [[ ! -d "${REPO_ROOT}/dashboard/node_modules" ]]; then
        fail "dashboard/node_modules not found"
        info  "Fix: cd dashboard && npm install"
        return 1
    fi

    info "Formatting dashboard files (Prettier) …"
    (cd "${REPO_ROOT}/dashboard" && npm run format --silent)

    if _staged_files_modified '^dashboard/'; then
        fail "Dashboard files were reformatted by Prettier — re-stage the changes and commit again"
        return 1
    fi

    pass "Dashboard formatting OK"
}

check_ui_contract() {
    header "Dashboard · UI Contract"

    if [[ ! -d "${REPO_ROOT}/dashboard/node_modules" ]]; then
        fail "dashboard/node_modules not found"
        info  "Fix: cd dashboard && npm install"
        return 1
    fi

    # ui:contract:check = ui:contract:validate (schema + token drift + semver)
    #                   + ui:contract:test     (fixture-based tests)
    #
    # Does NOT extract or rebuild the contract — those are developer actions
    # (see README_DEV.md §9.4.4) and should never run automatically here.
    info "Validating UI contract + running fixture tests …"
    if (cd "${REPO_ROOT}/dashboard" && npm run ui:contract:check --silent 2>&1); then
        pass "UI contract OK"
    else
        fail "UI contract check failed"
        info  "Run 'npm run ui:contract:diff' inside dashboard/ for a detailed mismatch report"
        return 1
    fi
}

# ── check registry ─────────────────────────────────────────────────────────
# Add new check function names here to enable them. Order matters.

CHECKS=(
    check_python_format
    check_dashboard_format
    check_ui_contract
)

# ── runner ─────────────────────────────────────────────────────────────────

main() {
    printf "%b\n" "\n${BOLD}TranscriptionSuite — pre-commit checks${RESET}"
    printf "%b\n" "${CYAN}────────────────────────────────────────${RESET}"

    local failed=0

    for check_fn in "${CHECKS[@]}"; do
        if ! "${check_fn}"; then
            (( failed++ )) || true
        fi
    done

    echo ""
    if (( failed > 0 )); then
        printf "%b\n" "${RED}${BOLD}✖  ${failed} check(s) failed — commit aborted.${RESET}\n"
        exit 1
    fi

    printf "%b\n" "${GREEN}${BOLD}✔  All checks passed.${RESET}\n"
    exit 0
}

main
